#include <gtk/gtk.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <sys/wait.h>

typedef struct {
    char process_name[256];
    int pid;
    double memory_gb;
} ProcessInfo;

int compare_processes(const void *a, const void *b) {
    double memory_a = ((ProcessInfo *)a)->memory_gb;
    double memory_b = ((ProcessInfo *)b)->memory_gb;
    if (memory_b > memory_a) return 1;
    if (memory_b < memory_a) return -1;
    return 0;
}

double get_process_memory(int pid) {
    char path[512];
    snprintf(path, sizeof(path), "/proc/%d/status", pid);

    FILE *file = fopen(path, "r");
    if (!file) return 0.0;

    double memory_kb = 0.0;
    char line[256];
    while (fgets(line, sizeof(line), file)) {
        if (strncmp(line, "VmRSS:", 6) == 0) {
            sscanf(line, "VmRSS: %lf", &memory_kb);
            break;
        }
    }
    fclose(file);

    return memory_kb / (1024.0 * 1024.0);
}

void populate_processes(GtkComboBoxText *combo_box, const gchar *filter) {
    DIR *dir = opendir("/proc");
    if (!dir) {
        perror("Cannot open /proc");
        return;
    }
    struct dirent *entry;

    gtk_combo_box_text_remove_all(combo_box);

    ProcessInfo processes[1024];
    int count = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR && strtol(entry->d_name, NULL, 10) > 0) {
            char path[512];
            snprintf(path, sizeof(path), "/proc/%s/comm", entry->d_name);

            FILE *file = fopen(path, "r");
            if (!file) continue;

            char process_name[256];
            if (fgets(process_name, sizeof(process_name), file) != NULL) {
                process_name[strcspn(process_name, "\n")] = 0;

                if (filter && !strstr(process_name, filter) && !strstr(entry->d_name, filter)) {
                    fclose(file);
                    continue;
                }

                int pid = strtol(entry->d_name, NULL, 10);
                double memory_gb = get_process_memory(pid);

                processes[count].pid = pid;
                processes[count].memory_gb = memory_gb;
                strncpy(processes[count].process_name, process_name, sizeof(processes[count].process_name));
                count++;
            }
            fclose(file);
        }
    }
    closedir(dir);

    qsort(processes, count, sizeof(ProcessInfo), compare_processes);

    for (int i = 0; i < count; i++) {
        char item[1024];
        snprintf(item, sizeof(item), "%s --- %d (%.2f GB)", 
                 processes[i].process_name, processes[i].pid, processes[i].memory_gb);
        gtk_combo_box_text_append_text(combo_box, item);
    }
}

void on_combo_box_changed(GtkComboBoxText *combo_box, gpointer user_data) {
    GtkTextView *text_view = GTK_TEXT_VIEW(user_data);
    GtkTextBuffer *text_buffer = gtk_text_view_get_buffer(text_view);
    
    gtk_text_buffer_set_text(text_buffer, "", -1);
}

void read_process_memory(pid_t pid, void *address, void *buffer, size_t size) {
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        perror("ptrace attach failed");
        return;
    }

    waitpid(pid, NULL, 0);

    unsigned long addr = (unsigned long)address;
    size_t bytes_read = 0;

    while (bytes_read < size) {
        errno = 0;
        long data = ptrace(PTRACE_PEEKDATA, pid, (void *)addr, NULL);
        if (data == -1) {
            perror("ptrace peekdata failed");
            if (errno == ESRCH) {
                printf("No such process\n");
            } else if (errno == EIO) {
                printf("I/O error, possibly invalid address or access denied\n");
            }
            break;
        }

        size_t to_copy = sizeof(long);
        if (bytes_read + to_copy > size) {
            to_copy = size - bytes_read;
        }

        memcpy((char *)buffer + bytes_read, &data, to_copy);
        bytes_read += to_copy;
        addr += sizeof(long);
    }
    ptrace(PTRACE_DETACH, pid, NULL, NULL);
}

gboolean is_process_alive(int pid) {
    return kill(pid, 0) == 0;
}

void on_find_button_clicked(GtkButton *button, gpointer user_data) {
    if (getuid() != 0) {
        GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(button))),
                                                   GTK_DIALOG_MODAL,
                                                   GTK_MESSAGE_WARNING,
                                                   GTK_BUTTONS_OK,
                                                   "This operation requires administrator privileges. Please enter your password to proceed.");
        gtk_dialog_run(GTK_DIALOG(dialog));
        gtk_widget_destroy(dialog);

        gchar *command = "your_program"; 
        gchar **args = g_strsplit(command, " ", -1);

        g_spawn_async(NULL, args, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, NULL, NULL);
        g_strfreev(args);
        return;
    }

    GtkComboBoxText *box_process = GTK_COMBO_BOX_TEXT(user_data);
    GtkTextView *box_strings = GTK_TEXT_VIEW(g_object_get_data(G_OBJECT(button), "box_strings"));
    GtkWidget *result_window = GTK_WIDGET(g_object_get_data(G_OBJECT(button), "result_window"));
    GtkLabel *result_label = GTK_LABEL(g_object_get_data(G_OBJECT(result_window), "result_label"));
    GtkTextView *result_text_view = GTK_TEXT_VIEW(g_object_get_data(G_OBJECT(result_window), "result_text_view"));

    gchar *selected_process = gtk_combo_box_text_get_active_text(box_process);
    if (!selected_process) {
        g_print("Please select a process.\n");
        return;
    }
    int pid = -1;
    char process_name[256] = {0};
    if (sscanf(selected_process, "%255[^-] --- %d", process_name, &pid) != 2) {
        g_print("Failed to extract PID and process name from selection.\n");
        g_free(selected_process);
        return;
    }
    g_free(selected_process);

    if (!is_process_alive(pid)) {
        g_print("Process with PID %d is not running.\n", pid);
        gtk_label_set_text(result_label, "Process is not running.");
        return;
    }

    GtkTextBuffer *text_buffer = gtk_text_view_get_buffer(box_strings);
    GtkTextIter start, end;
    gtk_text_buffer_get_bounds(text_buffer, &start, &end);
    gchar *text_in_box = gtk_text_buffer_get_text(text_buffer, &start, &end, FALSE);

    if (text_in_box && *text_in_box != '\0') {
        gchar **lines = g_strsplit(text_in_box, "\n", -1);
        gboolean found = FALSE;

        for (int i = 0; lines[i] != NULL; i++) {
            gchar *line = lines[i];
            gchar **parts = g_strsplit(line, "---", 2);

            if (parts[0] && parts[1]) {
                const char *keyword = parts[0];
                const char *search_string = parts[1];

                char *buffer = malloc(4096);
                if (buffer == NULL) {
                    perror("Memory allocation failed");
                    break;
                }

                void *address = (void *)0x00000000;
                read_process_memory(pid, address, buffer, 4096);

                if (strstr(buffer, search_string)) {
                    GtkTextBuffer *result_buffer = gtk_text_view_get_buffer(result_text_view);
                    GtkTextIter result_end;
                    gtk_text_buffer_get_end_iter(result_buffer, &result_end);
                    
                    char result_line[512];
                    snprintf(result_line, sizeof(result_line), "%s | %s\n", keyword, search_string);
                    gtk_text_buffer_insert(result_buffer, &result_end, result_line, -1);
                    
                    found = TRUE;
                }

                free(buffer);
            }

            g_strfreev(parts);
        }
        g_strfreev(lines);
        
        if (!found) {
            gtk_label_set_text(result_label, "No matches found.");
        } else {
            gtk_label_set_text(result_label, "Search complete.");
        }
    }
}


static void activate(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    GtkWidget *fixed;
    GtkWidget *header;
    GtkWidget *icon;
    GtkCssProvider *css_provider;

    window = gtk_application_window_new(app);
    gtk_widget_set_name(window, "window");
    gtk_window_set_title(GTK_WINDOW(window), "Error Strings");
    gtk_window_set_default_size(GTK_WINDOW(window), 500, 600);
    gtk_window_set_resizable(GTK_WINDOW(window), FALSE);
    gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);

    GtkWidget *result_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(result_window), "Error Result");
    gtk_window_set_default_size(GTK_WINDOW(result_window), 400, 400);
    gtk_widget_set_name(GTK_WIDGET(result_window), "result_window");
    gtk_window_set_position(GTK_WINDOW(result_window), GTK_WIN_POS_CENTER);
    gtk_window_set_resizable(GTK_WINDOW(result_window), FALSE);
    GtkWidget *result_fixed = gtk_fixed_new();
    gtk_container_add(GTK_CONTAINER(result_window), result_fixed);
    GtkWidget *result_window_header = gtk_header_bar_new();
    gtk_window_set_titlebar(GTK_WINDOW(result_window), result_window_header);
    gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(result_window_header), TRUE);
    GtkWidget *result_title_label = gtk_label_new("Result");
    gtk_header_bar_set_custom_title(GTK_HEADER_BAR(result_window_header), result_title_label);
    GtkWidget *result_label = gtk_label_new("Result:");
    gtk_widget_set_name(GTK_WIDGET(result_label), "result_label");
    gtk_fixed_put(GTK_FIXED(result_fixed), result_label, 20, 20);
    GtkWidget *result_scrolled_window = gtk_scrolled_window_new(NULL, NULL);
    gtk_widget_set_size_request(result_scrolled_window, 360, 300);
    gtk_fixed_put(GTK_FIXED(result_fixed), result_scrolled_window, 20, 50);
    gtk_widget_set_name(GTK_WIDGET(result_scrolled_window), "result_scrolled_window");
    GtkWidget *result_text_view = gtk_text_view_new();
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(result_text_view), GTK_WRAP_WORD);
    gtk_text_view_set_editable(GTK_TEXT_VIEW(result_text_view), FALSE);
    gtk_container_add(GTK_CONTAINER(result_scrolled_window), result_text_view);
    gtk_widget_set_name(GTK_WIDGET(result_text_view), "result_text_view");

    fixed = gtk_fixed_new();
    gtk_container_add(GTK_CONTAINER(window), fixed);

    header = gtk_header_bar_new();
    gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(header), TRUE);
    gtk_window_set_titlebar(GTK_WINDOW(window), header);

    icon = gtk_image_new_from_resource("/df/error/imgs/logo.svg");
    gtk_widget_set_size_request(GTK_WIDGET(icon), 50, 50);
    gtk_fixed_put(GTK_FIXED(fixed), icon, 150, 7);
    gtk_widget_set_name(GTK_WIDGET(icon), "icon");

    GtkWidget *text = gtk_label_new("Error Strings");
    gtk_widget_set_size_request(GTK_WIDGET(text), 50, 50);
    gtk_fixed_put(GTK_FIXED(fixed), text, 215, 17);
    gtk_widget_set_name(GTK_WIDGET(text), "text");

    GtkWidget *box_process_label = gtk_label_new("Process: ");
    gtk_widget_set_size_request(GTK_WIDGET(box_process_label), 100, 30);
    gtk_fixed_put(GTK_FIXED(fixed), box_process_label, 30, 100);
    gtk_widget_set_name(GTK_WIDGET(box_process_label), "box_process_label");

    GtkWidget *box_process = gtk_combo_box_text_new();
    populate_processes(GTK_COMBO_BOX_TEXT(box_process), NULL);
    gtk_widget_set_size_request(GTK_WIDGET(box_process), 400, 20);
    gtk_fixed_put(GTK_FIXED(fixed), box_process, 50, 125);
    gtk_widget_set_name(GTK_WIDGET(box_process), "box_process");
    
    GtkWidget *box_strings_label = gtk_label_new("Strings: ");
    gtk_widget_set_size_request(GTK_WIDGET(box_strings_label), 100, 30);
    gtk_fixed_put(GTK_FIXED(fixed), box_strings_label, 30, 180);
    gtk_widget_set_name(GTK_WIDGET(box_strings_label), "box_strings_label");

    GtkWidget *scrolled_window = gtk_scrolled_window_new(NULL, NULL);
    gtk_widget_set_size_request(scrolled_window, 400, 250);
    gtk_fixed_put(GTK_FIXED(fixed), scrolled_window, 50, 205);
    gtk_widget_set_name(GTK_WIDGET(scrolled_window), "scrolled_window");
    GtkWidget *box_strings = gtk_text_view_new();
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(box_strings), GTK_WRAP_WORD);
    gtk_container_add(GTK_CONTAINER(scrolled_window), box_strings);
    gtk_widget_set_name(GTK_WIDGET(box_strings), "box_strings");
    g_signal_connect(box_process, "changed", G_CALLBACK(on_combo_box_changed), box_strings);

    GtkWidget *find_b = gtk_button_new_with_label("Find");
    gtk_widget_set_size_request(GTK_WIDGET(find_b), 70, 30);
    gtk_widget_set_name(GTK_WIDGET(find_b), "find_b");
    gtk_fixed_put(GTK_FIXED(fixed), find_b, 215, 470);
    g_signal_connect(find_b, "clicked", G_CALLBACK(on_find_button_clicked), box_process);
    g_object_set_data(G_OBJECT(find_b), "box_strings", box_strings);
    g_object_set_data(G_OBJECT(find_b), "result_window", result_window);
    g_object_set_data(G_OBJECT(result_window), "result_label", result_label);
    g_object_set_data(G_OBJECT(result_window), "result_text_view", result_text_view);


    css_provider = gtk_css_provider_new();
    gtk_css_provider_load_from_resource(css_provider, "/df/error/styles/style.css");
    gtk_style_context_add_provider_for_screen(gdk_screen_get_default(), GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);
    
    gtk_widget_show_all(window);
}

int main(int argc, char **argv) {
    GtkApplication *app = gtk_application_new("com.example.ErrorStrings", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}