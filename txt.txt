#include <gtk/gtk.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char process_name[256];
    int pid;
    double memory_gb;
} ProcessInfo;

int compare_processes(const void *a, const void *b) {
    double memory_a = ((ProcessInfo *)a)->memory_gb;
    double memory_b = ((ProcessInfo *)b)->memory_gb;
    if (memory_b > memory_a) return 1;
    if (memory_b < memory_a) return -1;
    return 0;
}

double get_process_memory(int pid) {
    char path[512];
    snprintf(path, sizeof(path), "/proc/%d/status", pid);

    FILE *file = fopen(path, "r");
    if (!file) return 0.0;

    double memory_kb = 0.0;
    char line[256];
    while (fgets(line, sizeof(line), file)) {
        if (strncmp(line, "VmRSS:", 6) == 0) {
            sscanf(line, "VmRSS: %lf", &memory_kb);
            break;
        }
    }
    fclose(file);

    return memory_kb / (1024.0 * 1024.0);
}

void populate_processes(GtkComboBoxText *combo_box, const gchar *filter) {
    DIR *dir = opendir("/proc");
    if (!dir) {
        perror("Cannot open /proc");
        return;
    }
    struct dirent *entry;

    gtk_combo_box_text_remove_all(combo_box);

    ProcessInfo processes[1024];
    int count = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR && strtol(entry->d_name, NULL, 10) > 0) {
            char path[512];
            snprintf(path, sizeof(path), "/proc/%s/comm", entry->d_name);

            FILE *file = fopen(path, "r");
            if (!file) continue;

            char process_name[256];
            if (fgets(process_name, sizeof(process_name), file) != NULL) {
                process_name[strcspn(process_name, "\n")] = 0;

                if (filter && !strstr(process_name, filter) && !strstr(entry->d_name, filter)) {
                    fclose(file);
                    continue;
                }

                int pid = strtol(entry->d_name, NULL, 10);
                double memory_gb = get_process_memory(pid);

                processes[count].pid = pid;
                processes[count].memory_gb = memory_gb;
                strncpy(processes[count].process_name, process_name, sizeof(processes[count].process_name));
                count++;
            }
            fclose(file);
        }
    }
    closedir(dir);

    qsort(processes, count, sizeof(ProcessInfo), compare_processes);

    for (int i = 0; i < count; i++) {
        char item[1024];
        snprintf(item, sizeof(item), "%s --- %d (%.2f GB)", 
                 processes[i].process_name, processes[i].pid, processes[i].memory_gb);
        gtk_combo_box_text_append_text(combo_box, item);
    }
}

void on_combo_box_changed(GtkComboBoxText *combo_box, gpointer user_data) {
    GtkTextView *text_view = GTK_TEXT_VIEW(user_data);
    GtkTextBuffer *text_buffer = gtk_text_view_get_buffer(text_view);
    
    gtk_text_buffer_set_text(text_buffer, "", -1);
}

void on_find_button_clicked(GtkButton *button, gpointer user_data) {
    GtkComboBoxText *box_process = GTK_COMBO_BOX_TEXT(user_data);
    GtkTextView *box_strings = GTK_TEXT_VIEW(g_object_get_data(G_OBJECT(button), "box_strings"));
    GtkWidget *result_window = GTK_WIDGET(g_object_get_data(G_OBJECT(button), "result_window"));

    gchar *selected_process = gtk_combo_box_text_get_active_text(box_process);
    if (!selected_process) {
        g_print("Please select a process.\n");
        return;
    }

    GtkTextBuffer *text_buffer = gtk_text_view_get_buffer(box_strings);
    GtkTextIter start, end;
    gtk_text_buffer_get_bounds(text_buffer, &start, &end);
    gchar *text_in_box = gtk_text_buffer_get_text(text_buffer, &start, &end, FALSE);

    if (text_in_box && *text_in_box != '\0') {
        gchar **lines = g_strsplit(text_in_box, "\n", -1);
        gboolean valid = TRUE;

        for (int i = 0; lines[i] != NULL; i++) {
            gchar *line = lines[i];
            gchar **parts = g_strsplit(line, "---", 2);

            if (parts[0] && parts[1]) {
                g_print("Name: %s\n", parts[0]);
                g_print("String: %s\n", parts[1]);
            } else {
                g_print("Invalid entry format\n");
                valid = FALSE;
                break;
            }
            g_strfreev(parts);
        }
        g_strfreev(lines);
        if (valid) {
            GtkWidget *result_window_header = gtk_header_bar_new();
            gtk_window_set_titlebar(GTK_WINDOW(result_window), result_window_header);
            gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(result_window_header), TRUE);
            
            GtkWidget *result_title_label = gtk_label_new(selected_process);
            gtk_header_bar_set_custom_title(GTK_HEADER_BAR(result_window_header), result_title_label);

            gtk_widget_show_all(result_window);
        }
        g_signal_connect(result_window, "delete-event", G_CALLBACK(gtk_widget_hide_on_delete), NULL);        
    } else {
        g_print("Please enter text in the Strings box.\n");
    }

    g_free(selected_process);
    g_free(text_in_box);
}

static void activate(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    GtkWidget *fixed;
    GtkWidget *header;
    GtkWidget *icon;
    GtkCssProvider *css_provider;

    window = gtk_application_window_new(app);
    gtk_widget_set_name(window, "window");
    gtk_window_set_title(GTK_WINDOW(window), "Error Strings");
    gtk_window_set_default_size(GTK_WINDOW(window), 500, 600);
    gtk_window_set_resizable(GTK_WINDOW(window), FALSE);
    gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);

    GtkWidget *result_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(result_window), "Error Result");
    gtk_window_set_default_size(GTK_WINDOW(result_window), 400, 400);
    gtk_widget_set_name(GTK_WIDGET(result_window), "result_window");
    gtk_window_set_position(GTK_WINDOW(result_window), GTK_WIN_POS_CENTER);
    gtk_window_set_resizable(GTK_WINDOW(result_window), FALSE);
    GtkWidget *result_window_header = gtk_header_bar_new();
    gtk_window_set_titlebar(GTK_WINDOW(result_window), result_window_header);
    gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(result_window_header), TRUE);
    
    GtkWidget *result_title_label = gtk_label_new("Result");
    gtk_header_bar_set_custom_title(GTK_HEADER_BAR(result_window_header), result_title_label);

    fixed = gtk_fixed_new();
    gtk_container_add(GTK_CONTAINER(window), fixed);

    header = gtk_header_bar_new();
    gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(header), TRUE);
    gtk_window_set_titlebar(GTK_WINDOW(window), header);

    icon = gtk_image_new_from_resource("/df/error/imgs/logo.svg");
    gtk_widget_set_size_request(GTK_WIDGET(icon), 50, 50);
    gtk_fixed_put(GTK_FIXED(fixed), icon, 150, 7);
    gtk_widget_set_name(GTK_WIDGET(icon), "icon");

    GtkWidget *text = gtk_label_new("Error Strings");
    gtk_widget_set_size_request(GTK_WIDGET(text), 50, 50);
    gtk_fixed_put(GTK_FIXED(fixed), text, 215, 17);
    gtk_widget_set_name(GTK_WIDGET(text), "text");

    GtkWidget *box_process_label = gtk_label_new("Process: ");
    gtk_widget_set_size_request(GTK_WIDGET(box_process_label), 100, 30);
    gtk_fixed_put(GTK_FIXED(fixed), box_process_label, 30, 100);
    gtk_widget_set_name(GTK_WIDGET(box_process_label), "box_process_label");

    GtkWidget *box_process = gtk_combo_box_text_new();
    populate_processes(GTK_COMBO_BOX_TEXT(box_process), NULL);
    gtk_widget_set_size_request(GTK_WIDGET(box_process), 400, 20);
    gtk_fixed_put(GTK_FIXED(fixed), box_process, 50, 125);
    gtk_widget_set_name(GTK_WIDGET(box_process), "box_process");
    
    GtkWidget *box_strings_label = gtk_label_new("Strings: ");
    gtk_widget_set_size_request(GTK_WIDGET(box_strings_label), 100, 30);
    gtk_fixed_put(GTK_FIXED(fixed), box_strings_label, 30, 180);
    gtk_widget_set_name(GTK_WIDGET(box_strings_label), "box_strings_label");

    GtkWidget *scrolled_window = gtk_scrolled_window_new(NULL, NULL);
    gtk_widget_set_size_request(scrolled_window, 400, 250);
    gtk_fixed_put(GTK_FIXED(fixed), scrolled_window, 50, 205);
    gtk_widget_set_name(GTK_WIDGET(scrolled_window), "scrolled_window");
    GtkWidget *box_strings = gtk_text_view_new();
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(box_strings), GTK_WRAP_WORD);
    gtk_container_add(GTK_CONTAINER(scrolled_window), box_strings);
    gtk_widget_set_name(GTK_WIDGET(box_strings), "box_strings");
    g_signal_connect(box_process, "changed", G_CALLBACK(on_combo_box_changed), box_strings);

    GtkWidget *find_b = gtk_button_new_with_label("Find");
    gtk_widget_set_size_request(GTK_WIDGET(find_b), 70, 30);
    gtk_widget_set_name(GTK_WIDGET(find_b), "find_b");
    gtk_fixed_put(GTK_FIXED(fixed), find_b, 215, 470);
    g_signal_connect(find_b, "clicked", G_CALLBACK(on_find_button_clicked), box_process);
    g_object_set_data(G_OBJECT(find_b), "box_strings", box_strings);
    g_object_set_data(G_OBJECT(find_b), "result_window", result_window);

    css_provider = gtk_css_provider_new();
    gtk_css_provider_load_from_data(css_provider,
        "#window { background-color: #292929; }"
        "#text { font-size: 20px; font-weight: 600; color: #B7B7B7; }"
        "#box_process_label, #box_strings_label { font-size: 15px; font-weight: 600; color: #B7B7B7; }"
        "#box_strings, #scrolled_window { border: #181818 solid 1px; border-radius: 7px; background-color: #373737 }"
        "#find_b { font-size: 15px; color: #b7b7b7; }"
        "#box_process { font-size: 13px; }"
        ,
        -1,
        NULL);

    GtkStyleContext *context = gtk_widget_get_style_context(window);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(text);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(box_process_label);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(box_strings_label);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(box_strings);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(scrolled_window);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(find_b);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    context = gtk_widget_get_style_context(box_process);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(css_provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

    gtk_widget_show_all(window);
}

int main(int argc, char **argv) {
    GtkApplication *app = gtk_application_new("com.example.ErrorStrings", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}




Сделай еще функционал для программы:
1. Сделай так что бы программа проверяла есть ли в box_strings что то перед --- и после ---, если нету - Invalid entry format
2. Если перед или после --- ТОЛЬКО пробелы без других символов: Invalid entry format
3. Сделай так что бы после успешного открытия result_window программа начала искать  значение string из box_strings в строках выбранного процесса(из box_process) и в нем(result_window) было 4 колонки
Name, String, Address, Data

Name - тут будет показываться значение Name из box_strings
String - тут будет показываться значение String из box_stirngs
Address - тут будет address найденой строки в процессе
Data - тут будет дата появления этой строки в процессе

И под этими колонками будут значения которые находились(если их будет больше чем 5 то снизу будет цифри которыми можно будет переключать страницы с результатами(в каждой странице до 5 РЕЗУЛЬТАТОВ)) количество страниц будет зависить от коичества результатов

ПОЛНЫЙ КОД САМ НАПИШИ